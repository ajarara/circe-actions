* ZNCirce
A suite of functions that interface with ZNC's various modules accessible by private message (eg, "/msg *status help").

This code requires circe, and invoking it assumes you are connected to a ZNC instance.
** A brief overview
ZNC is an IRC relay. Instead of connecting directly to a network, I have a server handle the connections for me on a VPS, which allows me numerous benefits:
*** Context on rejoining a channel
It always seems to be the case all the interesting discussion starts right before you join the channel. Without appropriate context it might take a bit of guessing before you can understand what is being discussed (or alternatively, wait for some new discussion topic or whatever). Why do this when we have the giant hammer of technology to smash our fly problems?

ZNC allows you to have a buffer of lines kept that is played back to you when you join a channel. This is useful for two reasons: aforementioned context and an elimination of the need to have your computer connected to the internet 24/7. This is particularly invaluable when you are connected to a channel that has little discussion.
*** Easy client-agnostic per channel configuration
While I like having tons of channels open, I don't necessarily need all this information. Having 3000 lines of buffered content played back to me is overload. Instead, I'd like certain channels to be buffered a specific degree. There are two ways to do this, through the web administration module, and through the control panel module.

The web administration module is just a webserver that requires you to log in and you can edit all sorts of things on a serverwide, userwide, or channelwide basis. ZNC has a remarkable degree of customization backed by great documentation.

Unfortunately with the webadmin, you have to trade off convenience for security: it is enabled to listen on external interfaces. If someone has access to your ZNC password, they can impersonate you, and even get shell access. So I disabled it on external interfaces, instead requiring me to use SSH (mentioned again later)

The controlpanel proves a much more convenient way to handle this configuration. But it is rather verbose to change on the fly. That is what this code aims to solve.

** Todo
*** (require 'circe)
Or rather, figure out how to turn this into an eventual package for consumption using Cask and autoloads and whatnot. I know a lot of people use ZNC, and a lot of people use circe (and erc).
*** Check if connected to a ZNC instance 
Is it important to check everytime a function runs or sufficient to check once per circe session?
*** Split functionality of circe-actions and zncirce
Circe-actions should provide an interface to (circe-irc-handler-table)
This allows us to split functionality and hopefully use our concepts when extended to ERC.

*** Generating functions
The way ZNCirce works is it first places an event handler in Circe's irc.message handler, using irc-handler-add (the internal representation is a hash table with irc.message as a key, and handlers as a list of functions)

You can inspect this with (gethash "irc.message" (circe-irc-handler-table)) while in a circe buffer. It's an empty list. (fun fact, '() and nil are exactly alike once evaluated, and only serve as indicators as to what the behavior of the variable is.)

In reality, handlers aren't all that expensive, but it likely is important to not pollute them, as they are all called everytime someone sends a message, which happens a lot once you have lots of channels open (I have 31).

Any function on an irc.message handler (the only handler that is dealt with in this package) is called with the following arguments:

**** server-proc
I'm honestly not sure. I can't really inspect this because elisp doesn't have any string-martialing. The source says (circe-server-process) when it passes to all these handlers, so it's highly likely, but I can't say it for sure.

**** event
In this case, "irc.message". Strange that this is included, but I could see a use case where you dispatch one function to many different handlers at once.
**** fq-username
Not the nick, the nick and some address information, or the cloak (what you'd get from /whois, if you could /whois *status)

ie 
#+BEGIN_SRC 
/whois fsbot
#+END_SRC
yields:
#+BEGIN_SRC 
fsbot is ~fsbot@unaffiliated/deego/bot/fsbot (The Free Software bot)
#+END_SRC

What you get is a concatenation of these two strings (minus the description):

fsbot!~fsbot@unaffiliated/deego/bot/fsbot

In our case, the modules we're interfacing look like *controlpanel!znc@znc.in
**** channel
Where was it sent to? It can be a channel, but if it's a query/PM, then it's the nick it was sent to (ie, yours).

**** contents
What did the fq-username send us?
*** 

So what we would like to do is generate functions that can handle these separately. For example, I'd like the ability to get the message back from *controlpanel and display it in the minibuffer, but I don't want to do it just for *controlpanel, I'd also like to do it with *status. The way we can do this is with macros generating functions that take these parameters as arguments. This allows us to generate an irc.message handler factory.

One problem is that it is difficult (probably impossible) to refer to generated functions from macro expressions without giving them symbols to later refer to them by. I didn't want to pollute the function space (I think it's called the obarray in elisp, but I might be wrong as it is a lisp-2). 

Interning symbols?
*** Dynamic binding?

*** ZNC's aversion to git
ZNC sports a config file, but users are discouraged from editing it directly, instead being pointed to using the web admin panel. I've disabled the web admin panel pointing on public IP addresses (which funnily enough required me editing the config file by hand), only allowing those with SSH access to use it (using SSH tunneling to forward ports to localhost)

Unfortunately, this means that any configuration I make towards ZNC is not reproducible. Unless, I have some way to get that configuration file, and put it into version control. There are two ways I'm thinking of doing this:

**** Remote git
ZNC sports a commandline interface for administrators to use. This is kind of scary, specifically because I don't change my IRC password /that/ often and I know someone even mildly security oriented is already reading this with wide eyes.

The gist of it is that I put the git repository in the server holding the config file, and use some git transport mechanism (likely either through circe or ssh) to clone the repo locally.

***** Pros
Well it does the job

***** Cons
I really don't want the commandline interface to be enabled, it's far too large of an attack vector for my paranoia.

Further, it's complicated. I'd need to have some way to transport commit messages (or auto generate them, but that is useless when it comes to diagnostics), then some way to get the repo over here (without cloning it to some external git repo, as this contains plaintext passwords).

**** Write a module that retrieves the file and returns it over IRC
This is less disastrous. I don't need git to exist on the remote server, and don't need anything besides the ability to retrieve a single file (the only goodies of the file are the irc passwords, which you would already have access to if you know my ZNC password)

***** Pros
MUCH less security risk
Modules can be written in Python, which I am familiar with

***** Cons
None. Ha!





