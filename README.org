* circe-actions.el
** What is circe?
[[https://github.com/jorgenschaefer/circe][Circe]] is an IRC client for emacs sporting what most would call sane defaults. It has lots of features, not least of which is the ability to run arbitrary elisp code on many events.

** What is circe-actions?
A convenient interface to building functions to put on circe's event table.

Most use cases call for circe-actions-register, which does almost all of the heavy lifting by generating the function for you, assigning it an uninterned symbol (i.e. one that won't pollute the function namespace), and placing it on an alist and the event hook (really a hash table with events as keys). 

This magical function asks for 3 arguments (and an optional one):

*** Condition-p-function
This parameter should be a procedure that will be passed arguments depending on the event. For example, any "irc.message" event passes 5 arguments to a function on the handler-table ([[#event-signatures][Event signatures]] describes known arguments for each event). When the procedure returns non-nil, the action-function is then called.

*** Action-function
This parameter should be a procedure that will be passed arguments in the exact same order as condition-p-function, and does whatever you want it to do.

Whatever is returned from the action-function is returned from the whole generated function, but the "hook"-runner (irc-handler-run in irc.el) doesn't care about the return value.

*** Event
Should be the string associated with the event. Look to [[#event-signatures][event signatures]] for descriptions of each of these events.

*** Persist
If persist is set, the procedure does not remove itself after being called once. This is potentially very dangerous if your condition function is computationally expensive (or, y'know, monetarily expensive). Be careful!

Additionally, this can be used if you want to capture the next n events satisfying a specific criteria, handling the dectivation yourself, as illustrated in [[#capture-n-things-then-quit][this example]

** Example usage
Say I want to capture the next time someone sends me a private message. I can use either PRIVMSG, or irc.message, both seem to be equivalent. First we need a condition function:
#+BEGIN_SRC emacs-lisp
  (defun you-talkin-to-me?-p (server-proc event fq-username channel contents)
    (equal channel "alphor"))
#+END_SRC

That's it! (Coincidentally this use case is probably pretty common, and so there are functions that make this considerably less verbose, take a look at circe-actions-sent-to-p and its liberal cousin, circe-actions-hippie-sent-to-p, which both make use of closures to get you what you want. Usage in [[#utility-functions][utility functions]]).

Then we need an action function. Using xfce4's notify-send, I can let myself know who sent me a message and what they said, even if emacs is not focused.
#+BEGIN_SRC emacs-lisp
  (defun who-said-what? (server-proc event fq-username channel contents)
    (async-shell-command (concat "notify-send " "\"" fq-username " sent you: " contents "\"")))
#+END_SRC

Finally it's a simple matter of registering it:
 #+BEGIN_SRC emacs-lisp
   (circe-actions-register 'you-talkin-to-me?-p
                           'who-said-what?
                           "irc.message")
#+END_SRC

This only happens once. If you want it to persist beyond the first time you-talkin-to-me?-p is satisfied, just set the persist flag, as such:
#+BEGIN_SRC emacs-lisp
  (circe-actions-register 'you-talkin-to-me?-p
                          'who-said-what?
                          "irc.message"
                          t)
#+END_SRC

Now this happens for the rest of your session!

** How this works
Circe has an event handler table, a hash table accessed by a function called (circe-irc-handler-table), which is filled with different buckets, with events as values. When Circe becomes aware of the event, it runs whatever is in the bucket associated with the event (a list of functions with a specific signature, or the empty list). Then when each element of the list has ran, Circe does whatever it does to handle the event itself. If it encounters an error, though, then the event will not be fully handled by Circe! This can mean missed messages if you don't test your functions before registering them.

Circe-actions handles all the bureaucracy of adding functions to this table, keeping track of them with circe-actions-handlers-alist and even providing functions to deactivate them (circe-actions-deactivate-function).

*** Event signatures
Parameters are passed in the order described.
| Event name  | Description                     | Parameters                                         |
| irc.message | Fired on every message or query | server-proc, event, fq-username, channel, contents |


Parameter description
**** server-proc
The circe-server-process providing the event.

**** event
In this case, "irc.message". Strange that this is included, but I could see a use case where you dispatch one function to many different handlers at once.
**** fq-username
The fully qualified username:

Not the nick, the nick and some address information, or the cloak (what you'd get from /whois, if you could /whois *status)

ie 
#+BEGIN_SRC 
/whois fsbot
#+END_SRC
yields:
#+BEGIN_SRC 
fsbot is ~fsbot@unaffiliated/deego/bot/fsbot (The Free Software bot)
#+END_SRC

What you get is a concatenation of these two strings (minus the description):

#+BEGIN_SRC 
fsbot!~fsbot@unaffiliated/deego/bot/fsbot
#+END_SRC

**** channel
Where was it sent to? It can be a channel, but if it's a query/PM, then it's the nick it was sent to (ie, yours).

**** contents
What did the fq-username send us?

*** Lower level registration
This is useful if we want to control how the function deactivates itself, especially if our use case doesn't really follow a callback style.

The only thing we have to keep in mind is that if we don't use circe-actions-register, we have to handle the deactivation step within the function (unless we don't want to deactivate the function, of course).
#+BEGIN_SRC emacs-lisp
  ;; we need closures to illustrate this example without descending into madness
  (setq lexical-binding t)
  (setq function-symbol (gensym "arbitrary-"))

  (defun message-five-times-then-quit ()
    (defalias function-symbol ; function-symbol is evaluated to get the symbol generated above
      (let ((count 0)) ; we increment this each time the lambda is called.

        (lambda (&rest arglist)
          (if (< count 5) ; condition function
              (let ((message-var (nth 4 arglist)))
                (setq count (1+ count))
                (message message-var)) ; action function
            (circe-actions-deactivate-function function-symbol "irc.message"))))))
              

  (circe-actions-activate-function (message-five-times-then-quit) ; return a new closure
                                   "irc.message")  
#+END_SRC

Of course if you want to bind all this to a key you could wrap all of it in an interactive function, like so:
#+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)

  (defun message-five-times-then-quit ()
    (interactive)
    (let ((function-symbol (gensym "arbitrary-"))
          (event "irc.message")) ; might as well parameterize it here
      (defalias function-symbol
        (let ((count 0))
          (lambda (&rest arglist)
            (if (< count 5) ; condition function
                (let ((message-var (nth 4 arglist)))
                  (setq count (1+ count))
                  (message message-var)) ; action-function
              (circe-actions-deactivate-function function-symbol event)))))
      (circe-actions-activate-function function-symbol event)))

#+END_SRC


*** Utility functions

**** Circe-actions-panic
In the case that something is tripping the debugger 3 times a second, you'll probably want this. It iterates through the alist holding all the registered functions and removes them from the handler table (and the alist).

**** circe-actions-t
In case you want to capture the next event unconditionally, you may be tempted to use t as a condition function. This won't work. Instead, you must wrap t in a lambda that takes in the correct number of arguments. circe-actions-t is exactly this.

**** Lexically bound functions
These are all functions that make it easy to devise condition functions without dealing with the rather large function signature needed. Once called, they will return an appropriate closure satisfying the condition you want.
***** circe-actions-is-from-p
Usage: (circe-actions-from-p "alphor!~floor13@2604:180:2::10")
Returns true when the event was caused by the sender.

Wait does this mean that you can only reliably target cloaks? Yes. This is more useful for ZNC, when you want to make absolutely sure you got the message from the right entity. But don't worry, my child:
***** circe-actions-hippie-is-from-p
Usage: (circe-actions-hippie-is-from-p "alphor!~")
Does precisely what you think it does. If you make it too loose, then of course this will fire on events you don't really care about.
***** circe-actions-sent-to-p
Usage: (circe-actions-sent-to-p "alphor!~floor13@2604:140:76::5")
Whoever the event is targeting. It can be a nick or a channel.
***** circe-actions-hippie-sent-to-p
Usage: (circe-actions-hippie-sent-to-p "alph")
Does precisely what you think it does.
***** circe-actions-pass-then-deactivate
This one is a little too niche to describe its usage immediately. Perhaps you want something in between a callback and a persistent action.

* ZNCirce.el
A suite of functions that interface with ZNC's various modules accessible by private message (eg, "/msg *status help").

This code requires circe, and circe-actions (zncirce.el is little more than a wrapper around circe-actions), and invoking it assumes you are connected to a ZNC instance.

** Usage
*** zncirce-get-buffer-for-chan
This does not get the emacs-lisp buffer, but instead displays the value of the buffer variable associated with a specific channel. The buffer variable with respect to ZNC is the number of lines played to you when you initially connect.

*** zncirce-save-config
After making changes, ZNC does not automatically save configuration (in case you make a customization that is rogue). If you're happy with the way ZNC behaves, this will save your configuration on the remote machine, making the config persist on reboot.

** Todo
*** Check if connected to a ZNC instance 
Is it important to check everytime a function runs or sufficient to check once per circe session?
*** Generalized *controlpanel interface
IE: zncirce-setchan would prompt for a buffer, then a variable, and based on that, prompt for either a string, integer, or boolean, and send them to *controlpanel.

There is a small problem with this. There are lots of variables at each level, and it probably varies completely across ZNC versions. I could start with a default set, and have a utility function that runs obtaining the help info, saving the values as a tuple (or just the differences).
*** Fix % bug in circe-actions-message-contents
If you don't want to format the string, (message "%s" VALUE). This avoids any bugs if someone sends a message with % in it.

*** ZNC's aversion to git
ZNC sports a config file, but users are discouraged from editing it directly, instead being pointed to using the web admin panel. I've disabled the web admin panel pointing on public IP addresses (which funnily enough required me editing the config file by hand), only allowing those with SSH access to use it (using SSH tunneling to forward ports to localhost)

Unfortunately, this means that any configuration I make towards ZNC is not reproducible. Unless, I have some way to get that configuration file, and put it into version control. There are two ways I'm thinking of doing this:

**** Remote git
ZNC sports a commandline interface for administrators to use. This is kind of scary, specifically because I don't change my IRC password /that/ often and I know someone even mildly security oriented is already shaking their head.

The gist of it is that I put the git repository in the server holding the config file, and use some git transport mechanism (likely either through circe or ssh) to clone the repo locally.

***** Pros
Well it does the job

***** Cons
I really don't want the commandline interface to be enabled, it's far too large of an attack vector for my paranoia.

Further, it's complicated. I'd need to have some way to transport commit messages (or auto generate them, but that is useless when it comes to diagnostics), then some way to get the repo over here (without cloning it to some external git repo, as this contains plaintext passwords).

**** Write a module that retrieves the file and returns it over IRC
This is less disastrous. I don't need git to exist on the remote server, and don't need anything besides the ability to retrieve a single file (the only goodies of the file are the irc passwords, which you would already have access to if you know the ZNC admin password)

***** Pros
MUCH less security risk
Modules can be written in Python, which I am familiar with

***** Cons
More time investment.





